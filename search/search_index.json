{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"JSTP / JavaScript Transfer Protocol JSTP is an RPC protocol and framework which provides two-way asynchronous data transfer with support of multiple parallel non-blocking interactions that is so transparent that an app may not even distinguish between local async functions and remote procedures. Installation \u00b6 JSTP works in Node.js and web browsers: $ npm install --save @metarhia/jstp Or, alternatively, there is jstp.umd.js UMD bundle. We also have official client-side implementations for Swift and Java that work effortlessly on iOS and Android \ud83c\udf89 There is also an interactive CLI provided by this package: $ npm install -g @metarhia/jstp $ jstp-cli","title":"Home"},{"location":"#installation","text":"JSTP works in Node.js and web browsers: $ npm install --save @metarhia/jstp Or, alternatively, there is jstp.umd.js UMD bundle. We also have official client-side implementations for Swift and Java that work effortlessly on iOS and Android \ud83c\udf89 There is also an interactive CLI provided by this package: $ npm install -g @metarhia/jstp $ jstp-cli","title":"Installation"},{"location":"VERSIONING/","text":"Versioning \u00b6 Package versioning \u00b6 When we reach 1.0, we will just adhere to semantic versioning strictly, but semver says nothing about versions <1.0.0 . Thus we extend semver's rules applying them to these versions this way: in 0.minor.patch scheme minor acts as a major semver version and patch as both minor and patch, regardless of whether a change is a feature or a bugfix. Accordingly, if labels named semver-major or semver-minor are added to any issue or pull request before we have released v1.0.0 , they actually assume minor and patch subversions. Protocol versioning \u00b6 Before the package reaches version 1.0.0, the protocol version is bound to the first of the metarhia-jstp package versions that implement the same specification of the protocol. It would be nice to have it versioned independently, but it's too late to do it, since we haven't been versioning it from the beginning and we have made changes to the specification multiple times. When the package reaches 1.0.0, the protocol version will be unconditionally bumped to 1.0.0 too, regardless of whether metarhia-jstp@1.0.0 brings any changes to the protocol. We will then take this as a starting point and the protocol specification will be versioned with semver independently from the package.","title":"Versioning"},{"location":"VERSIONING/#versioning","text":"","title":"Versioning"},{"location":"VERSIONING/#package-versioning","text":"When we reach 1.0, we will just adhere to semantic versioning strictly, but semver says nothing about versions <1.0.0 . Thus we extend semver's rules applying them to these versions this way: in 0.minor.patch scheme minor acts as a major semver version and patch as both minor and patch, regardless of whether a change is a feature or a bugfix. Accordingly, if labels named semver-major or semver-minor are added to any issue or pull request before we have released v1.0.0 , they actually assume minor and patch subversions.","title":"Package versioning"},{"location":"VERSIONING/#protocol-versioning","text":"Before the package reaches version 1.0.0, the protocol version is bound to the first of the metarhia-jstp package versions that implement the same specification of the protocol. It would be nice to have it versioned independently, but it's too late to do it, since we haven't been versioning it from the beginning and we have made changes to the specification multiple times. When the package reaches 1.0.0, the protocol version will be unconditionally bumped to 1.0.0 too, regardless of whether metarhia-jstp@1.0.0 brings any changes to the protocol. We will then take this as a starting point and the protocol specification will be versioned with semver independently from the package.","title":"Protocol versioning"},{"location":"advanced/","text":"Advanced Topics \u00b6 This section outlines topics that are not required and barely interesting for most users of the library, but essential for hacking the library itself or reimplementing the protocol for other platforms and languages.","title":"Advanced Topics"},{"location":"advanced/#advanced-topics","text":"This section outlines topics that are not required and barely interesting for most users of the library, but essential for hacking the library itself or reimplementing the protocol for other platforms and languages.","title":"Advanced Topics"},{"location":"advanced/protocol/","text":"JavaScript Transfer Protocol \u00b6 WARNING: THIS DOCUMENT IS VASTLY OUTDATED AND MISLEADING. JSTP is a data transfer protocol that uses JavaScript objects syntax as the encoding format and supports metadata. The protocol has 8 types of packets: call \u2014 remote API call; callback \u2014 remote API response; event \u2014 event with attached data; state \u2014 data synchronization; stream \u2014 data streaming; handshake \u2014 protocol handshake; health \u2014 system data about resource state and usage; inspect \u2014 API introspection request; this list is a subject to change. // Packet ID 17, remote call, interface auth, method newAccount { call : [ 17 , 'auth' ], newAccount : [ 'Payload data' ]} // Response to packet 17, operation is successful, record ID is 15703 { callback : [ 17 ], ok : [ 15703 ]} // Event in packet 18, interface auth, event named insert { event : [ 18 , 'auth' ], insert : [ 'Marcus Aurelius' , 'AE127095' ]} Packet structure: a packet is an object with several keys; the first one is a header, the name of this key is the packet type, its elements are: [0] \u2014 unique number that identifies the packet inside the connection; packet with ID 0 is sent by a client (the side that initiated the connection) and the client increments it by 1 with each request; a server has a separate counter that is being decremented by 1 with each request or response to the client; if any of the sides sends a request (like call or inspect ), another one responds with a callback packet with the same ID. [1] \u2014 resource identifier: in call , event and inspect \u2014 name of an interface; in state \u2014 identifier of the mutating object; the second key is identifier: in call \u2014 method name; in callback - response status ( ok or error ); in event \u2014 event name; in state \u2014 method identifier ( inc , dec , delete , let , push , pop , shift , unshift ); in inspect \u2014 no value; in stream \u2014 no value. Remote Call Packet call \u00b6 Example: { call : [ 3 , 'interfaceName' ], methodName : [ 'Payload data' ]} Remote Call Response Packet callback \u00b6 Examples: { callback : [ 14 ], ok : [ 15703 ]} { callback : [ 397 ], error : [ 4 , 'Data validation failed' ]} { callback : [ - 23 ], ok : []} Remote Event Packet event \u00b6 Examples: { event : [ - 12 , 'chat' ], message : [ 'Marcus' , 'Hello there!' ]} { event : [ 51 , 'game' ], vote : [ 5 ]} { event : [ - 79 , 'db' ], insert : [ 'Marcus' , 'Aurelius' , 'Rome' , 'AE127095' ]} Data Synchronization Packet state \u00b6 Examples: { state : [ - 12 , 'object.path.prop1' ], inc : 5 } { state : [ - 13 , 'object.path.prop2' ], dec : 1 } { state : [ - 14 , 'object.path.prop3' ], let : 700 } { state : [ - 15 , 'object.path.prop4' ], let : 'Hello' } { state : [ - 16 , 'object.path.prop5' ], let : { f : 55 }} { state : [ - 17 , 'object.path.prop5' ], let : [ 1 , 2 , 7 ]} { state : [ - 18 , 'object.path.prop6' ], delete : 0 } { state : [ - 19 , 'object.path.set1' ], let : [ 'A' , 'D' ]} { state : [ - 20 , 'object.path.set1' ], push : 'C' } { state : [ - 20 , 'object.path.set2' ], let : [ 5 , 6 , 9 ]} { state : [ - 20 , 'object.path.set2' ], push : 12 } { state : [ - 20 , 'object.path.set2' ], pop : 2 } { state : [ - 20 , 'object.path.set2' ], shift : 3 } { state : [ - 20 , 'object.path.set2' ], delete : 5 } { state : [ - 20 , 'object.path.set2' ], unshift : 1 } Data Stream Packet stream \u00b6 Examples: { stream : [ 9 ], data : 'Payload start...' } { stream : [ 9 ], data : '...continue...' } { stream : [ 9 ], data : '...end' } Handshake Packet handshake \u00b6 Handshake packets always have ID equal to 0 . The response contains either the key ok with a value that is the session identifier or error that is an array with error code and optional error message. The action field of handshake requests specifies the authentication strategy. There are two supported strategies now: login \u2014 authentication with login and password. The payload is an array of two elements: username and password, both represented as strings. anonymous \u2014 anonymous session request. The payload is ignored (e.g., true or an empty array may be used). For anonymous handshakes the action field can be omitted completely, anonymous is implied by default. More strategies may be added in the future (for example, session to reconnect to an existing session after connection break due to a network error). Successful handshake: C : { handshake : [ 0 , 'example' ], login : [ 'marcus' , '7b458e1a9dda....67cb7a3e' ]} S : { handshake : [ 0 ], ok : '9b71d224bd62...bcdec043' } In this excerpt 'example' is the name of an application, marcus is the user name and 9b71d224bd62...bcdec043 is the session id. Successful anonymous handshake: C : { handshake : [ 0 , 'example' ]} S : { handshake : [ 0 ], ok : 'f3785d96d46a...def46f73' } It may be necessary for registration or public service. Server responds with a session ID. Successful handshake of Impress worker connecting to a private cloud controller: C : { handshake : [ 0 , 'impress' ], login : [ 'S1N5' , 'd3ea3d73319b...5c2e5c3a' ]} S : { handshake : [ 0 ], ok : 'PrivateCloud' } PrivateCloud is the name of a cloud and d3ea3d73319b...5c2e5c3a is the cloud access key. Application not found: C : { handshake : [ 0 , 'example' ], marcus : 'fbc2890caada...0c466347' } S : { handshake : [ 0 ], error : [ 10 , 'Application not found' ]} In this example marcus is username and fbc2890caada...0c466347 is salted sha512 hash of a password. Authentication error: C : { handshake : [ 0 , 'example' ], marcus : 'e2dff7251967...14b8c5da' } S : { handshake : [ 0 ], error : [ 11 , 'Authentication failed' ]} Introspection Request Packet inspect \u00b6 This packet is being sent for remote API introspection request and can be initiated by either side. Just like the call packet, the other side responds with a callback packet. Example of a successful introspection retrieval: C : { inspect : [ 42 , 'interfaceName' ]} S : { callback : [ 42 ], ok : [ 'method1' , 'method2' ]} Error getting the introspection: C : { inspect : [ 15 , 'unknownInterface' ]} S : { callback : [ 15 ], error : [ 12 , 'Interface not found' ]} Data Transmission and Packet Aggregation \u00b6 TCP \u00b6 TCP protocol transfers a stream of data, so fragments sent sequentially are glued and cut in any positions by the protocol. In order to split the stream into separate messages we must either specify the length of each packet or include message terminators. JSTP uses terminator that allows to accumulate and split the buffer quite efficiently. Each JSTP packet must end with a null character. When a TCP packet arrives, each null character is replaced with a comma and the result is put into the buffer (while the empty buffer always has the [ character). As soon as the received packet ends with a terminator, after character replacement and putting the data into the buffer, the ] character is placed into the buffer and its whole content is parsed. WebSocket \u00b6 Since the WebSocket API used in browsers doesn't expose the vanilla frame-based or streaming API (though supported by WebSocket protocol) but only message-based one which splits messages into frames and aggregates them back together automatically, and all the major WebSocket implementations are capable of that too, there's no need to build the same mechanism again on top of WebSocket and induce unnecessary overhead because of situation that will never happen.","title":"JavaScript Transfer Protocol"},{"location":"advanced/protocol/#javascript-transfer-protocol","text":"WARNING: THIS DOCUMENT IS VASTLY OUTDATED AND MISLEADING. JSTP is a data transfer protocol that uses JavaScript objects syntax as the encoding format and supports metadata. The protocol has 8 types of packets: call \u2014 remote API call; callback \u2014 remote API response; event \u2014 event with attached data; state \u2014 data synchronization; stream \u2014 data streaming; handshake \u2014 protocol handshake; health \u2014 system data about resource state and usage; inspect \u2014 API introspection request; this list is a subject to change. // Packet ID 17, remote call, interface auth, method newAccount { call : [ 17 , 'auth' ], newAccount : [ 'Payload data' ]} // Response to packet 17, operation is successful, record ID is 15703 { callback : [ 17 ], ok : [ 15703 ]} // Event in packet 18, interface auth, event named insert { event : [ 18 , 'auth' ], insert : [ 'Marcus Aurelius' , 'AE127095' ]} Packet structure: a packet is an object with several keys; the first one is a header, the name of this key is the packet type, its elements are: [0] \u2014 unique number that identifies the packet inside the connection; packet with ID 0 is sent by a client (the side that initiated the connection) and the client increments it by 1 with each request; a server has a separate counter that is being decremented by 1 with each request or response to the client; if any of the sides sends a request (like call or inspect ), another one responds with a callback packet with the same ID. [1] \u2014 resource identifier: in call , event and inspect \u2014 name of an interface; in state \u2014 identifier of the mutating object; the second key is identifier: in call \u2014 method name; in callback - response status ( ok or error ); in event \u2014 event name; in state \u2014 method identifier ( inc , dec , delete , let , push , pop , shift , unshift ); in inspect \u2014 no value; in stream \u2014 no value.","title":"JavaScript Transfer Protocol"},{"location":"advanced/protocol/#remote-call-packet-call","text":"Example: { call : [ 3 , 'interfaceName' ], methodName : [ 'Payload data' ]}","title":"Remote Call Packet call"},{"location":"advanced/protocol/#remote-call-response-packet-callback","text":"Examples: { callback : [ 14 ], ok : [ 15703 ]} { callback : [ 397 ], error : [ 4 , 'Data validation failed' ]} { callback : [ - 23 ], ok : []}","title":"Remote Call Response Packet callback"},{"location":"advanced/protocol/#remote-event-packet-event","text":"Examples: { event : [ - 12 , 'chat' ], message : [ 'Marcus' , 'Hello there!' ]} { event : [ 51 , 'game' ], vote : [ 5 ]} { event : [ - 79 , 'db' ], insert : [ 'Marcus' , 'Aurelius' , 'Rome' , 'AE127095' ]}","title":"Remote Event Packet event"},{"location":"advanced/protocol/#data-synchronization-packet-state","text":"Examples: { state : [ - 12 , 'object.path.prop1' ], inc : 5 } { state : [ - 13 , 'object.path.prop2' ], dec : 1 } { state : [ - 14 , 'object.path.prop3' ], let : 700 } { state : [ - 15 , 'object.path.prop4' ], let : 'Hello' } { state : [ - 16 , 'object.path.prop5' ], let : { f : 55 }} { state : [ - 17 , 'object.path.prop5' ], let : [ 1 , 2 , 7 ]} { state : [ - 18 , 'object.path.prop6' ], delete : 0 } { state : [ - 19 , 'object.path.set1' ], let : [ 'A' , 'D' ]} { state : [ - 20 , 'object.path.set1' ], push : 'C' } { state : [ - 20 , 'object.path.set2' ], let : [ 5 , 6 , 9 ]} { state : [ - 20 , 'object.path.set2' ], push : 12 } { state : [ - 20 , 'object.path.set2' ], pop : 2 } { state : [ - 20 , 'object.path.set2' ], shift : 3 } { state : [ - 20 , 'object.path.set2' ], delete : 5 } { state : [ - 20 , 'object.path.set2' ], unshift : 1 }","title":"Data Synchronization Packet state"},{"location":"advanced/protocol/#data-stream-packet-stream","text":"Examples: { stream : [ 9 ], data : 'Payload start...' } { stream : [ 9 ], data : '...continue...' } { stream : [ 9 ], data : '...end' }","title":"Data Stream Packet stream"},{"location":"advanced/protocol/#handshake-packet-handshake","text":"Handshake packets always have ID equal to 0 . The response contains either the key ok with a value that is the session identifier or error that is an array with error code and optional error message. The action field of handshake requests specifies the authentication strategy. There are two supported strategies now: login \u2014 authentication with login and password. The payload is an array of two elements: username and password, both represented as strings. anonymous \u2014 anonymous session request. The payload is ignored (e.g., true or an empty array may be used). For anonymous handshakes the action field can be omitted completely, anonymous is implied by default. More strategies may be added in the future (for example, session to reconnect to an existing session after connection break due to a network error). Successful handshake: C : { handshake : [ 0 , 'example' ], login : [ 'marcus' , '7b458e1a9dda....67cb7a3e' ]} S : { handshake : [ 0 ], ok : '9b71d224bd62...bcdec043' } In this excerpt 'example' is the name of an application, marcus is the user name and 9b71d224bd62...bcdec043 is the session id. Successful anonymous handshake: C : { handshake : [ 0 , 'example' ]} S : { handshake : [ 0 ], ok : 'f3785d96d46a...def46f73' } It may be necessary for registration or public service. Server responds with a session ID. Successful handshake of Impress worker connecting to a private cloud controller: C : { handshake : [ 0 , 'impress' ], login : [ 'S1N5' , 'd3ea3d73319b...5c2e5c3a' ]} S : { handshake : [ 0 ], ok : 'PrivateCloud' } PrivateCloud is the name of a cloud and d3ea3d73319b...5c2e5c3a is the cloud access key. Application not found: C : { handshake : [ 0 , 'example' ], marcus : 'fbc2890caada...0c466347' } S : { handshake : [ 0 ], error : [ 10 , 'Application not found' ]} In this example marcus is username and fbc2890caada...0c466347 is salted sha512 hash of a password. Authentication error: C : { handshake : [ 0 , 'example' ], marcus : 'e2dff7251967...14b8c5da' } S : { handshake : [ 0 ], error : [ 11 , 'Authentication failed' ]}","title":"Handshake Packet handshake"},{"location":"advanced/protocol/#introspection-request-packet-inspect","text":"This packet is being sent for remote API introspection request and can be initiated by either side. Just like the call packet, the other side responds with a callback packet. Example of a successful introspection retrieval: C : { inspect : [ 42 , 'interfaceName' ]} S : { callback : [ 42 ], ok : [ 'method1' , 'method2' ]} Error getting the introspection: C : { inspect : [ 15 , 'unknownInterface' ]} S : { callback : [ 15 ], error : [ 12 , 'Interface not found' ]}","title":"Introspection Request Packet inspect"},{"location":"advanced/protocol/#data-transmission-and-packet-aggregation","text":"","title":"Data Transmission and Packet Aggregation"},{"location":"advanced/protocol/#tcp","text":"TCP protocol transfers a stream of data, so fragments sent sequentially are glued and cut in any positions by the protocol. In order to split the stream into separate messages we must either specify the length of each packet or include message terminators. JSTP uses terminator that allows to accumulate and split the buffer quite efficiently. Each JSTP packet must end with a null character. When a TCP packet arrives, each null character is replaced with a comma and the result is put into the buffer (while the empty buffer always has the [ character). As soon as the received packet ends with a terminator, after character replacement and putting the data into the buffer, the ] character is placed into the buffer and its whole content is parsed.","title":"TCP"},{"location":"advanced/protocol/#websocket","text":"Since the WebSocket API used in browsers doesn't expose the vanilla frame-based or streaming API (though supported by WebSocket protocol) but only message-based one which splits messages into frames and aggregates them back together automatically, and all the major WebSocket implementations are capable of that too, there's no need to build the same mechanism again on top of WebSocket and induce unnecessary overhead because of situation that will never happen.","title":"WebSocket"},{"location":"api/application/","text":"Application \u00b6 Class: jstp.Application \u00b6 Generic application class. You are free to substitute it with other class with the same interface that suits your needs. Constructor: new Application(name, api[, eventHandlers[, version][, ssp]]) \u00b6 name <string> Application name that may contain version after '@' (e.g. app@1.0.0). Version in name is preferred over 'version' parameter. api <Object> [interfaceName] <Object> Keys with the arbitrary names that will be used as the remote interface names. [methodName] <Function> Keys with the arbitrary names that will be used as the remote method names. connection <Connection> ...args <any> callback <Function> eventHandlers <Object> [interfaceName] <Object> Keys with the arbitrary names that will be used as the remote interface names. [eventName] <Function> Keys with the arbitrary names that will be used as the remote event names. connection <Connection> ...args <any> version <string> If a version is not provided either here or in name , 1.0.0 is used. ssp <SessionStorageProvider> If provided, it is used to store sessions independently of other applications. application.callMethod(connection, interfaceName, methodName, args, callback) \u00b6 connection <Connection> interfaceName <string> methodName <string> args <Array> callback <Function> This method is called when handling incoming 'call' message. application.getMethods(interfaceName) \u00b6 interfaceName <string> Name of the interface to inspect. Returns: <string[]> Array of method names of the interface. This method is called when handling incoming 'inspect' message. application.handleEvent(connection, interfaceName, eventName, args) \u00b6 connection <Connection> interfaceName <string> eventName <string> args <Array> This method is called when handling incoming 'event' message. jstp.createAppsIndex(applications) \u00b6 applications <Application[]> Returns: <Map> Created index. Create an index of applications from an array.","title":"Application"},{"location":"api/application/#application","text":"","title":"Application"},{"location":"api/application/#class-jstpapplication","text":"Generic application class. You are free to substitute it with other class with the same interface that suits your needs.","title":"Class: jstp.Application"},{"location":"api/application/#constructor-new-applicationname-api91-eventhandlers91-version9391-ssp9393","text":"name <string> Application name that may contain version after '@' (e.g. app@1.0.0). Version in name is preferred over 'version' parameter. api <Object> [interfaceName] <Object> Keys with the arbitrary names that will be used as the remote interface names. [methodName] <Function> Keys with the arbitrary names that will be used as the remote method names. connection <Connection> ...args <any> callback <Function> eventHandlers <Object> [interfaceName] <Object> Keys with the arbitrary names that will be used as the remote interface names. [eventName] <Function> Keys with the arbitrary names that will be used as the remote event names. connection <Connection> ...args <any> version <string> If a version is not provided either here or in name , 1.0.0 is used. ssp <SessionStorageProvider> If provided, it is used to store sessions independently of other applications.","title":"Constructor: new Application(name, api[, eventHandlers[, version][, ssp]])"},{"location":"api/application/#applicationcallmethodconnection-interfacename-methodname-args-callback","text":"connection <Connection> interfaceName <string> methodName <string> args <Array> callback <Function> This method is called when handling incoming 'call' message.","title":"application.callMethod(connection, interfaceName, methodName, args, callback)"},{"location":"api/application/#applicationgetmethodsinterfacename","text":"interfaceName <string> Name of the interface to inspect. Returns: <string[]> Array of method names of the interface. This method is called when handling incoming 'inspect' message.","title":"application.getMethods(interfaceName)"},{"location":"api/application/#applicationhandleeventconnection-interfacename-eventname-args","text":"connection <Connection> interfaceName <string> eventName <string> args <Array> This method is called when handling incoming 'event' message.","title":"application.handleEvent(connection, interfaceName, eventName, args)"},{"location":"api/application/#jstpcreateappsindexapplications","text":"applications <Application[]> Returns: <Map> Created index. Create an index of applications from an array.","title":"jstp.createAppsIndex(applications)"},{"location":"api/auth-policy/","text":"AuthPolicy \u00b6 Interface: jstp.AuthPolicy \u00b6 authPolicy.authenticate(connection, application, strategy, credentials, callback) \u00b6 connection <Connection> application <Application> strategy <string> credentials <Array> callback <Function> error <Error> username <string>","title":"AuthPolicy"},{"location":"api/auth-policy/#authpolicy","text":"","title":"AuthPolicy"},{"location":"api/auth-policy/#interface-jstpauthpolicy","text":"","title":"Interface: jstp.AuthPolicy"},{"location":"api/auth-policy/#authpolicyauthenticateconnection-application-strategy-credentials-callback","text":"connection <Connection> application <Application> strategy <string> credentials <Array> callback <Function> error <Error> username <string>","title":"authPolicy.authenticate(connection, application, strategy, credentials, callback)"},{"location":"api/client/","text":"Client \u00b6 Interface: jstp.Client \u00b6 Client object is used to specify client-side connection behavior. client.connectPolicy(application, connection[, session], callback) \u00b6 application <string> | <Object> connection <Connection> session <Session> callback <Function> error <Error> | <null> connection <Connection> session <Session> The application may be 'name' , 'name@version' or { name, version } , where version must be a valid semver range. The session is passed to this function when the client is reconnecting to the existing session. In that case, implementations of this interface are not required to pass session argument to the callback . If this field is not set, new SimpleConnectPolicy().connect() is used. It is also possible to set this field to an object with the connect() method having the same signature. client.application \u00b6 <Application> Client-side application instance to be exposed over connection. If this field is not set, an Application jstp@1.0.0 with an empty api is used. client.heartbeatInterval \u00b6 <number> Setting this field enables heartbeat. client.session \u00b6 <Session> Setting this field results in using the 'session' authentication strategy when connecting, which can be used to reconnect to the existing session. client.logger \u00b6 <EventEmitter> Optional EventEmitter object to use for logging. If this field is not set, logging events are emitted on the connection object itself. Available logging events are listed in the Connection class. client.reconnector(connection, reconnectFn) \u00b6 connection <Connection> reconnectFn <Function> transport <string> Optional argument, can be passed to switch transport on reconnection. ...options <any> Optional options to be passed to transport.connect() function. callback <Function> Optional callback to be called after finishing the reconnection attempt. When set, this function will be called after the connection is closed and can be used to reconnect to the same or different server by calling reconnectFn and providing options in the same way they are provided when connecting to the server. It is also possible to use another transport by providing its name as the first argument to reconnectFn . In case no transport and/or options were provided to reconnectFn , values from the previous successful connection attempt are to be used. To completely stop reconnecting do not call reconnectFn inside this function. In case this field is not set, default reconnector that provides exponential backoff functionality is used.","title":"Client"},{"location":"api/client/#client","text":"","title":"Client"},{"location":"api/client/#interface-jstpclient","text":"Client object is used to specify client-side connection behavior.","title":"Interface: jstp.Client"},{"location":"api/client/#clientconnectpolicyapplication-connection91-session93-callback","text":"application <string> | <Object> connection <Connection> session <Session> callback <Function> error <Error> | <null> connection <Connection> session <Session> The application may be 'name' , 'name@version' or { name, version } , where version must be a valid semver range. The session is passed to this function when the client is reconnecting to the existing session. In that case, implementations of this interface are not required to pass session argument to the callback . If this field is not set, new SimpleConnectPolicy().connect() is used. It is also possible to set this field to an object with the connect() method having the same signature.","title":"client.connectPolicy(application, connection[, session], callback)"},{"location":"api/client/#clientapplication","text":"<Application> Client-side application instance to be exposed over connection. If this field is not set, an Application jstp@1.0.0 with an empty api is used.","title":"client.application"},{"location":"api/client/#clientheartbeatinterval","text":"<number> Setting this field enables heartbeat.","title":"client.heartbeatInterval"},{"location":"api/client/#clientsession","text":"<Session> Setting this field results in using the 'session' authentication strategy when connecting, which can be used to reconnect to the existing session.","title":"client.session"},{"location":"api/client/#clientlogger","text":"<EventEmitter> Optional EventEmitter object to use for logging. If this field is not set, logging events are emitted on the connection object itself. Available logging events are listed in the Connection class.","title":"client.logger"},{"location":"api/client/#clientreconnectorconnection-reconnectfn","text":"connection <Connection> reconnectFn <Function> transport <string> Optional argument, can be passed to switch transport on reconnection. ...options <any> Optional options to be passed to transport.connect() function. callback <Function> Optional callback to be called after finishing the reconnection attempt. When set, this function will be called after the connection is closed and can be used to reconnect to the same or different server by calling reconnectFn and providing options in the same way they are provided when connecting to the server. It is also possible to use another transport by providing its name as the first argument to reconnectFn . In case no transport and/or options were provided to reconnectFn , values from the previous successful connection attempt are to be used. To completely stop reconnecting do not call reconnectFn inside this function. In case this field is not set, default reconnector that provides exponential backoff functionality is used.","title":"client.reconnector(connection, reconnectFn)"},{"location":"api/connection/","text":"Connection \u00b6 Class: jstp.Connection \u00b6 Constructor: new Connection(transport, server, client) \u00b6 transport <Transport> server <Server> client <Client> Either server or client must be provided, but not both. server is required for server side connection, whereas client is required for client side connection. You should not call this constructor manually, unless you implement a custom JSTP transport. Recommended approach is to call connect() or connectAndInspect() functions provided by these modules: net tls ws ws-browser wss Event: 'reconnectAttempt' \u00b6 transport <string> Transport name. ...options <any> Options passed to transport.connect() . Client-side only event emitted before attempting the reconnection. Event: 'reconnect' \u00b6 error <Error> | <null> The error that occurred during reconnection if any. Client-side only event emitted after the reconnection attempt. Event: 'client' \u00b6 session <Session> connection <Connection> Server-side only event emitted on successful session creation or restoration. Event: 'call' \u00b6 interfaceName <string> methodName <string> args <Array> Logging event emitted when a 'call' message is received. Logging events are not emitted when there is a dedicated logger specified in the client object. Event: 'callback' \u00b6 error <Array> ok <Array> Logging event emitted when a 'callback' message is received. Event: 'event' \u00b6 interfaceName <string> eventName <string> args <Array> Logging event emitted when an 'event' message is received. Event: 'handshake' \u00b6 error <Array> ok <string> | <number> Session ID if the session was created or count of the messages received by the other side if the session is restored. Logging event emitted when a 'handshake' message response is received. Event: 'heartbeat' \u00b6 message <Object> Empty object. Logging event emitted when an old style ( '{}\\0' ) heartbeat message is received. Emitted only when process.env.NODE_ENV !== 'production' . Event: 'incomingMessage' \u00b6 message <Object> Message object. Logging event emitted when a message is received. Emitted only when process.env.NODE_ENV !== 'production' . Event: 'outgoingMessage' \u00b6 message <Object> Message object. Logging event emitted when a message is sent. Emitted only when process.env.NODE_ENV !== 'production' . Event: 'inspect' \u00b6 intefaceName <string> Logging event emitted when an 'inspect' message is received. Event: 'messageRejected' \u00b6 message <Object> Message object. Logging event emitted when a message is rejected. connection.handshake(app[, session], callback) \u00b6 app <string> | <Object> name <string> version <string> session <Session> callback <Function> error <RemoteError> sessionId <string> app may be 'name' , 'name@version' or { name, version } , where version must be a valid semver range. Send a handshake message over the connection. When session is provided, uses 'session' authentication strategy, 'anonymous' authentication strategy is used otherwise. connection.handshake(app, login, password, callback) \u00b6 app <string> | <Object> name <string> version <string> login <string> password <string> callback <Function> error <RemoteError> sessionId <string> app may be 'name' , 'name@version' or { name, version } , where version must be a valid semver range. Send a handshake message over the connection using 'login' authentication strategy. connection.inspectInterface(interfaceName, callback) \u00b6 interfaceName <string> callback <Function> error <RemoteError> proxy <RemoteProxy> Send an inspect message over the connection. connection.callMethod(interfaceName, methodName, args, callback) \u00b6 interfaceName <string> methodName <string> args <Array> callback <Function> error <RemoteError> ...args <Array> Send a call message over the connection. connection.callMethodWithResend(interfaceName, methodName, args, callback) \u00b6 interfaceName <string> methodName <string> args <Array> callback <Function> error <RemoteError> ...args <Array> Send a call message over the connection resending if not possible to get a callback. connection.emitRemoteEvent(interfaceName, eventName, args) \u00b6 interfaceName <string> eventName <string> args <Array> Send an event message over the connection. connection.ping(callback) \u00b6 callback <Function> Send a ping message. connection.startHeartbeat(interval) \u00b6 interval <number> Start periodically sending ping messages every interval milliseconds. connection.stopHeartbeat() \u00b6 Stop periodically sending ping messages. connection.close() \u00b6 Close the connection. connection.getTransport() \u00b6 Returns: <Transport> Returns underlying transport. connection.server \u00b6 <Server> connection.client \u00b6 <Client> connection.id \u00b6 <number> Unique for this process connection identifier. connection.remoteAddress \u00b6 <any> Value obtained from connection.getTransport().remoteAddress . connection.handshakeDone \u00b6 <boolean> connection.username \u00b6 <string> May be null if connection was established without logging in. connection.session \u00b6 <Session> connection.application \u00b6 <Application> connection.remoteProxies \u00b6 <Object> [interfaceName] <RemoteProxy>","title":"Connection"},{"location":"api/connection/#connection","text":"","title":"Connection"},{"location":"api/connection/#class-jstpconnection","text":"","title":"Class: jstp.Connection"},{"location":"api/connection/#constructor-new-connectiontransport-server-client","text":"transport <Transport> server <Server> client <Client> Either server or client must be provided, but not both. server is required for server side connection, whereas client is required for client side connection. You should not call this constructor manually, unless you implement a custom JSTP transport. Recommended approach is to call connect() or connectAndInspect() functions provided by these modules: net tls ws ws-browser wss","title":"Constructor: new Connection(transport, server, client)"},{"location":"api/connection/#event-reconnectattempt","text":"transport <string> Transport name. ...options <any> Options passed to transport.connect() . Client-side only event emitted before attempting the reconnection.","title":"Event: 'reconnectAttempt'"},{"location":"api/connection/#event-reconnect","text":"error <Error> | <null> The error that occurred during reconnection if any. Client-side only event emitted after the reconnection attempt.","title":"Event: 'reconnect'"},{"location":"api/connection/#event-client","text":"session <Session> connection <Connection> Server-side only event emitted on successful session creation or restoration.","title":"Event: 'client'"},{"location":"api/connection/#event-call","text":"interfaceName <string> methodName <string> args <Array> Logging event emitted when a 'call' message is received. Logging events are not emitted when there is a dedicated logger specified in the client object.","title":"Event: 'call'"},{"location":"api/connection/#event-callback","text":"error <Array> ok <Array> Logging event emitted when a 'callback' message is received.","title":"Event: 'callback'"},{"location":"api/connection/#event-event","text":"interfaceName <string> eventName <string> args <Array> Logging event emitted when an 'event' message is received.","title":"Event: 'event'"},{"location":"api/connection/#event-handshake","text":"error <Array> ok <string> | <number> Session ID if the session was created or count of the messages received by the other side if the session is restored. Logging event emitted when a 'handshake' message response is received.","title":"Event: 'handshake'"},{"location":"api/connection/#event-heartbeat","text":"message <Object> Empty object. Logging event emitted when an old style ( '{}\\0' ) heartbeat message is received. Emitted only when process.env.NODE_ENV !== 'production' .","title":"Event: 'heartbeat'"},{"location":"api/connection/#event-incomingmessage","text":"message <Object> Message object. Logging event emitted when a message is received. Emitted only when process.env.NODE_ENV !== 'production' .","title":"Event: 'incomingMessage'"},{"location":"api/connection/#event-outgoingmessage","text":"message <Object> Message object. Logging event emitted when a message is sent. Emitted only when process.env.NODE_ENV !== 'production' .","title":"Event: 'outgoingMessage'"},{"location":"api/connection/#event-inspect","text":"intefaceName <string> Logging event emitted when an 'inspect' message is received.","title":"Event: 'inspect'"},{"location":"api/connection/#event-messagerejected","text":"message <Object> Message object. Logging event emitted when a message is rejected.","title":"Event: 'messageRejected'"},{"location":"api/connection/#connectionhandshakeapp91-session93-callback","text":"app <string> | <Object> name <string> version <string> session <Session> callback <Function> error <RemoteError> sessionId <string> app may be 'name' , 'name@version' or { name, version } , where version must be a valid semver range. Send a handshake message over the connection. When session is provided, uses 'session' authentication strategy, 'anonymous' authentication strategy is used otherwise.","title":"connection.handshake(app[, session], callback)"},{"location":"api/connection/#connectionhandshakeapp-login-password-callback","text":"app <string> | <Object> name <string> version <string> login <string> password <string> callback <Function> error <RemoteError> sessionId <string> app may be 'name' , 'name@version' or { name, version } , where version must be a valid semver range. Send a handshake message over the connection using 'login' authentication strategy.","title":"connection.handshake(app, login, password, callback)"},{"location":"api/connection/#connectioninspectinterfaceinterfacename-callback","text":"interfaceName <string> callback <Function> error <RemoteError> proxy <RemoteProxy> Send an inspect message over the connection.","title":"connection.inspectInterface(interfaceName, callback)"},{"location":"api/connection/#connectioncallmethodinterfacename-methodname-args-callback","text":"interfaceName <string> methodName <string> args <Array> callback <Function> error <RemoteError> ...args <Array> Send a call message over the connection.","title":"connection.callMethod(interfaceName, methodName, args, callback)"},{"location":"api/connection/#connectioncallmethodwithresendinterfacename-methodname-args-callback","text":"interfaceName <string> methodName <string> args <Array> callback <Function> error <RemoteError> ...args <Array> Send a call message over the connection resending if not possible to get a callback.","title":"connection.callMethodWithResend(interfaceName, methodName, args, callback)"},{"location":"api/connection/#connectionemitremoteeventinterfacename-eventname-args","text":"interfaceName <string> eventName <string> args <Array> Send an event message over the connection.","title":"connection.emitRemoteEvent(interfaceName, eventName, args)"},{"location":"api/connection/#connectionpingcallback","text":"callback <Function> Send a ping message.","title":"connection.ping(callback)"},{"location":"api/connection/#connectionstartheartbeatinterval","text":"interval <number> Start periodically sending ping messages every interval milliseconds.","title":"connection.startHeartbeat(interval)"},{"location":"api/connection/#connectionstopheartbeat","text":"Stop periodically sending ping messages.","title":"connection.stopHeartbeat()"},{"location":"api/connection/#connectionclose","text":"Close the connection.","title":"connection.close()"},{"location":"api/connection/#connectiongettransport","text":"Returns: <Transport> Returns underlying transport.","title":"connection.getTransport()"},{"location":"api/connection/#connectionserver","text":"<Server>","title":"connection.server"},{"location":"api/connection/#connectionclient","text":"<Client>","title":"connection.client"},{"location":"api/connection/#connectionid","text":"<number> Unique for this process connection identifier.","title":"connection.id"},{"location":"api/connection/#connectionremoteaddress","text":"<any> Value obtained from connection.getTransport().remoteAddress .","title":"connection.remoteAddress"},{"location":"api/connection/#connectionhandshakedone","text":"<boolean>","title":"connection.handshakeDone"},{"location":"api/connection/#connectionusername","text":"<string> May be null if connection was established without logging in.","title":"connection.username"},{"location":"api/connection/#connectionsession","text":"<Session>","title":"connection.session"},{"location":"api/connection/#connectionapplication","text":"<Application>","title":"connection.application"},{"location":"api/connection/#connectionremoteproxies","text":"<Object> [interfaceName] <RemoteProxy>","title":"connection.remoteProxies"},{"location":"api/errors/","text":"Errors \u00b6 Many operations in JSTP may end up with an error instead of a result. Following the common Node.js convention, errors are always being passed as the first argument of callbacks of these operations and if the operation was successful, this argument will be null. This behavior is both consistent with the core Node.js API and allows the JSTP API to be wrapped into promises easily and even to be used with async/await, if you use these advanced features, while keeping compatibility with plain callback-based asynchronous code for those who prefer performance over convenience or those who are forced to use older versions of Node.js. Hanshakes, RPC invocations and introspection requests are special cases of such operations. If they end up with an error, this error will be sent over network. As you can see in handshake and callback packets description, such errors are serialized into arrays that contain an error code and an optional error description. A high-level abstraction for these arrays is the RemoteError class. Callbacks of the operations stated above will receive instances of RemoteError as the first argument if an error occured. However, when returning an error from a remote method, you can pass any of the following to a callback: RemoteError instance; Error instance; numeric error code; error message as a string; any other object that will return an error message as a result of its toString method. Array of 1 or 2 elements: [code, message] , where the code is a number and the optional message is a string. If an error code is unknown (i.e., in any case except the first and third ones) it will be set to zero. However, it is recommended to leverage error codes even for custom errors and return them instead of Error instances as it is more efficient to send numbers than strings. If a method throws an exception, the calling side will receive ERR_INTERNAL_API_ERROR . Predefined Error Codes \u00b6 jstp.ERR_APP_NOT_FOUND \u00b6 Value: 10 . Default message: 'Application not found' . jstp.ERR_AUTH_FAILED \u00b6 Value: 11 . Default message: 'Authentication failed' . jstp.ERR_INTERFACE_NOT_FOUND \u00b6 Value: 12 . Default message: 'Interface not found' . jstp.ERR_INTERFACE_INCOMPATIBLE \u00b6 Value: 13 . Default message: 'Incompatible interface' . jstp.ERR_METHOD_NOT_FOUND \u00b6 Value: 14 . Default message: 'Method not found' . jstp.ERR_NOT_A_SERVER \u00b6 Value: 15 . Default message: 'Not a server' . jstp.ERR_INTERNAL_API_ERROR \u00b6 Value: 16 . Default message: 'Internal API error' . Class: jstp.RemoteError \u00b6 This class extends Error and represents an error that has been received from a remote method call over network. new RemoteError(code[, message]) \u00b6 code <number> Error code. message <string> Error message. If the message is not provided, it is set to either code.toString() or one of the default messages if the code is one of the defined in this package (listed above). error.code \u00b6 <number> error.message \u00b6 <string> error.toJstpArray() \u00b6 Returns: <Array> Returns an array for JSTP packets. This array will always contain the error code and, if the message is not equal to code and the code is not one of predefined error codes, the error message. Class Method: RemoteError.fromJstpArray(array) \u00b6 array <Array> array from a JSTP packet. Returns: <RemoteError> This factory method creates a RemoteError instance from an array found in a JSTP packet. Class Method: RemoteError.getJstpArrayFor(error) \u00b6 error <RemoteError> | <Error> | <number> | <string> Error to be converted to an array for a JSTP packet. Returns: <Array> This function returns an array suitable to be sent in a JSTP packet from a RemoteError instance, an Error instance, an error code or an error message. If there is no error code (i.e., an Error or a String is passed), the error code is assumed to be 0 .","title":"Errors"},{"location":"api/errors/#errors","text":"Many operations in JSTP may end up with an error instead of a result. Following the common Node.js convention, errors are always being passed as the first argument of callbacks of these operations and if the operation was successful, this argument will be null. This behavior is both consistent with the core Node.js API and allows the JSTP API to be wrapped into promises easily and even to be used with async/await, if you use these advanced features, while keeping compatibility with plain callback-based asynchronous code for those who prefer performance over convenience or those who are forced to use older versions of Node.js. Hanshakes, RPC invocations and introspection requests are special cases of such operations. If they end up with an error, this error will be sent over network. As you can see in handshake and callback packets description, such errors are serialized into arrays that contain an error code and an optional error description. A high-level abstraction for these arrays is the RemoteError class. Callbacks of the operations stated above will receive instances of RemoteError as the first argument if an error occured. However, when returning an error from a remote method, you can pass any of the following to a callback: RemoteError instance; Error instance; numeric error code; error message as a string; any other object that will return an error message as a result of its toString method. Array of 1 or 2 elements: [code, message] , where the code is a number and the optional message is a string. If an error code is unknown (i.e., in any case except the first and third ones) it will be set to zero. However, it is recommended to leverage error codes even for custom errors and return them instead of Error instances as it is more efficient to send numbers than strings. If a method throws an exception, the calling side will receive ERR_INTERNAL_API_ERROR .","title":"Errors"},{"location":"api/errors/#predefined-error-codes","text":"","title":"Predefined Error Codes"},{"location":"api/errors/#jstperr_app_not_found","text":"Value: 10 . Default message: 'Application not found' .","title":"jstp.ERR_APP_NOT_FOUND"},{"location":"api/errors/#jstperr_auth_failed","text":"Value: 11 . Default message: 'Authentication failed' .","title":"jstp.ERR_AUTH_FAILED"},{"location":"api/errors/#jstperr_interface_not_found","text":"Value: 12 . Default message: 'Interface not found' .","title":"jstp.ERR_INTERFACE_NOT_FOUND"},{"location":"api/errors/#jstperr_interface_incompatible","text":"Value: 13 . Default message: 'Incompatible interface' .","title":"jstp.ERR_INTERFACE_INCOMPATIBLE"},{"location":"api/errors/#jstperr_method_not_found","text":"Value: 14 . Default message: 'Method not found' .","title":"jstp.ERR_METHOD_NOT_FOUND"},{"location":"api/errors/#jstperr_not_a_server","text":"Value: 15 . Default message: 'Not a server' .","title":"jstp.ERR_NOT_A_SERVER"},{"location":"api/errors/#jstperr_internal_api_error","text":"Value: 16 . Default message: 'Internal API error' .","title":"jstp.ERR_INTERNAL_API_ERROR"},{"location":"api/errors/#class-jstpremoteerror","text":"This class extends Error and represents an error that has been received from a remote method call over network.","title":"Class: jstp.RemoteError"},{"location":"api/errors/#new-remoteerrorcode91-message93","text":"code <number> Error code. message <string> Error message. If the message is not provided, it is set to either code.toString() or one of the default messages if the code is one of the defined in this package (listed above).","title":"new RemoteError(code[, message])"},{"location":"api/errors/#errorcode","text":"<number>","title":"error.code"},{"location":"api/errors/#errormessage","text":"<string>","title":"error.message"},{"location":"api/errors/#errortojstparray","text":"Returns: <Array> Returns an array for JSTP packets. This array will always contain the error code and, if the message is not equal to code and the code is not one of predefined error codes, the error message.","title":"error.toJstpArray()"},{"location":"api/errors/#class-method-remoteerrorfromjstparrayarray","text":"array <Array> array from a JSTP packet. Returns: <RemoteError> This factory method creates a RemoteError instance from an array found in a JSTP packet.","title":"Class Method: RemoteError.fromJstpArray(array)"},{"location":"api/errors/#class-method-remoteerrorgetjstparrayforerror","text":"error <RemoteError> | <Error> | <number> | <string> Error to be converted to an array for a JSTP packet. Returns: <Array> This function returns an array suitable to be sent in a JSTP packet from a RemoteError instance, an Error instance, an error code or an error message. If there is no error code (i.e., an Error or a String is passed), the error code is assumed to be 0 .","title":"Class Method: RemoteError.getJstpArrayFor(error)"},{"location":"api/net/","text":"net \u00b6 Object: jstp.net \u00b6 jstp.net.connect(app, client, ...args, callback) \u00b6 app <string> | <Object> Application to connect to as 'name' or 'name@version' or { name, version } , where version must be a valid semver range. client <Client> | <null> Optional, when omitted, an object with the default values for application , connectPolicy and reconnector is used. ...args <any> Arguments passed directly to net.connect() (except for connectListener ) callback <Function> error : <Error> connection : <Connection> jstp.net.connectAndInspect(app, client, interfaces, ...args, callback) \u00b6 app <string> | <Object> Application to connect to as 'name' or 'name@version' or { name, version } , where version must be a valid semver range. client <Client> | <null> Optional, when omitted, an object with the default values for application , connectPolicy and reconnector is used. interfaces <string[]> Interface names to perform inspect on. ...args <any> Arguments passed directly to net.connect() (except for connectListener ). callback <Function> error : <Error> connection : <Connection> proxies <Object> [interfaceName] <RemoteProxy> Connects to the server and sends 'inspect' messages for the requested interfaces. In case all of the inspect calls were successful, an object containing remote proxies is returned. It is possible, when using this method, to get an error jstp.ERR_INTERFACE_NOT_FOUND passed to the callback due to some of the 'inspect' calls failing, and still receive a usable connection object. jstp.net.reconnect(connection, ...args, callback) \u00b6 connection : <Connection> ...args <any> Arguments passed directly to net.connect() (except for connectListener ) callback <Function> error : <Error> connection : <Connection> This method can be used to reconnect to the same session without switching to the new Connection instance. At the moment, when using this on a still alive connection, server implementation provided by this package closes the previous network connection on its side, but in general, it is not recommended to use this method on such connections, since there is no guarantee that the server will close the already existing network connection during reconnection and thus it may result in a dangling network connection. jstp.net.createServer(options[, listener]) \u00b6 options <Object> | <Application[]> applications <Application[]> | Map Applications array or index obtained from jstp.createAppsIndex() . authPolicy <AuthPolicy> | <Function> If the function is provided, it is expected to have the same signature as AuthPolicy.authenticate() . sessionStorageProvider <SessionStorageProvider> If provided, this is used to store sessions for applications that do not have its own storage provider. Defaults to using SimpleSessionStorageProvider with its default settings. heartbeatInterval <number> Omitting this option disables heartbeat. clientExpirationTime <number> Time it takes for client's connection and corresponding session cache, stored in memory after the connection is closed, to expire. Defaults to 3600000 (1 hour). listener <Function> Automatically set as a listener for the 'connect' event. For additional options see documentation for net.createServer() . However, beware, some of the options may interfere with the correct functioning of the JSTP protocol. authPolicy is used whenever the handshake with authentication strategy other than 'anonymous' or 'session' is received. In case it is omitted from the options, using any other strategy will result in jstp.ERR_AUTH_FAILED error.","title":"net"},{"location":"api/net/#net","text":"","title":"net"},{"location":"api/net/#object-jstpnet","text":"","title":"Object: jstp.net"},{"location":"api/net/#jstpnetconnectapp-client-args-callback","text":"app <string> | <Object> Application to connect to as 'name' or 'name@version' or { name, version } , where version must be a valid semver range. client <Client> | <null> Optional, when omitted, an object with the default values for application , connectPolicy and reconnector is used. ...args <any> Arguments passed directly to net.connect() (except for connectListener ) callback <Function> error : <Error> connection : <Connection>","title":"jstp.net.connect(app, client, ...args, callback)"},{"location":"api/net/#jstpnetconnectandinspectapp-client-interfaces-args-callback","text":"app <string> | <Object> Application to connect to as 'name' or 'name@version' or { name, version } , where version must be a valid semver range. client <Client> | <null> Optional, when omitted, an object with the default values for application , connectPolicy and reconnector is used. interfaces <string[]> Interface names to perform inspect on. ...args <any> Arguments passed directly to net.connect() (except for connectListener ). callback <Function> error : <Error> connection : <Connection> proxies <Object> [interfaceName] <RemoteProxy> Connects to the server and sends 'inspect' messages for the requested interfaces. In case all of the inspect calls were successful, an object containing remote proxies is returned. It is possible, when using this method, to get an error jstp.ERR_INTERFACE_NOT_FOUND passed to the callback due to some of the 'inspect' calls failing, and still receive a usable connection object.","title":"jstp.net.connectAndInspect(app, client, interfaces, ...args, callback)"},{"location":"api/net/#jstpnetreconnectconnection-args-callback","text":"connection : <Connection> ...args <any> Arguments passed directly to net.connect() (except for connectListener ) callback <Function> error : <Error> connection : <Connection> This method can be used to reconnect to the same session without switching to the new Connection instance. At the moment, when using this on a still alive connection, server implementation provided by this package closes the previous network connection on its side, but in general, it is not recommended to use this method on such connections, since there is no guarantee that the server will close the already existing network connection during reconnection and thus it may result in a dangling network connection.","title":"jstp.net.reconnect(connection, ...args, callback)"},{"location":"api/net/#jstpnetcreateserveroptions91-listener93","text":"options <Object> | <Application[]> applications <Application[]> | Map Applications array or index obtained from jstp.createAppsIndex() . authPolicy <AuthPolicy> | <Function> If the function is provided, it is expected to have the same signature as AuthPolicy.authenticate() . sessionStorageProvider <SessionStorageProvider> If provided, this is used to store sessions for applications that do not have its own storage provider. Defaults to using SimpleSessionStorageProvider with its default settings. heartbeatInterval <number> Omitting this option disables heartbeat. clientExpirationTime <number> Time it takes for client's connection and corresponding session cache, stored in memory after the connection is closed, to expire. Defaults to 3600000 (1 hour). listener <Function> Automatically set as a listener for the 'connect' event. For additional options see documentation for net.createServer() . However, beware, some of the options may interfere with the correct functioning of the JSTP protocol. authPolicy is used whenever the handshake with authentication strategy other than 'anonymous' or 'session' is received. In case it is omitted from the options, using any other strategy will result in jstp.ERR_AUTH_FAILED error.","title":"jstp.net.createServer(options[, listener])"},{"location":"api/remote-proxy/","text":"RemoteProxy \u00b6 Class: jstp.RemoteProxy \u00b6 Remote API proxy object class that extends EventEmitter . It wraps remote methods so that they look like regular local methods and acts like a remote event emitter. Using proxy.on() you can subscribe to both local and remote events. Constructor: new RemoteProxy(connection, interfaceName[, methods]) \u00b6 connection <Connection> interfaceName <string> methods <string[]> proxy.emit(eventName, ...eventArgs) \u00b6 eventName <string> ...eventArgs <any> Emits event over the connection. It also emits the event on the proxy instance. proxy[methodName](...args, callback[, resend]) \u00b6 methodName <string> ...args <any> callback <Function> resend <boolean> If set to true, call message will be resent if it is not possible to get a callback.","title":"RemoteProxy"},{"location":"api/remote-proxy/#remoteproxy","text":"","title":"RemoteProxy"},{"location":"api/remote-proxy/#class-jstpremoteproxy","text":"Remote API proxy object class that extends EventEmitter . It wraps remote methods so that they look like regular local methods and acts like a remote event emitter. Using proxy.on() you can subscribe to both local and remote events.","title":"Class: jstp.RemoteProxy"},{"location":"api/remote-proxy/#constructor-new-remoteproxyconnection-interfacename91-methods93","text":"connection <Connection> interfaceName <string> methods <string[]>","title":"Constructor: new RemoteProxy(connection, interfaceName[, methods])"},{"location":"api/remote-proxy/#proxyemiteventname-eventargs","text":"eventName <string> ...eventArgs <any> Emits event over the connection. It also emits the event on the proxy instance.","title":"proxy.emit(eventName, ...eventArgs)"},{"location":"api/remote-proxy/#proxy91methodname93args-callback91-resend93","text":"methodName <string> ...args <any> callback <Function> resend <boolean> If set to true, call message will be resent if it is not possible to get a callback.","title":"proxy[methodName](...args, callback[, resend])"},{"location":"api/server/","text":"Server \u00b6 Class: jstp.Server \u00b6 JSTP server base class with necessary methods. All of the transport servers extend this class. Event: 'connect' \u00b6 <Connection> Emitted when a JSTP connection is established and new session is created. Event: 'reconnect' \u00b6 <Connection> Emitted when a JSTP connection is established that is reusing existing session . Event: 'disconnect' \u00b6 <Connection> Emitted when a JSTP connection is closed. server.getClients() \u00b6 Returns: <Iterator> Get all clients as an Iterator of Connection instances. server.getClientsArray() \u00b6 Returns: <Connection[]> server.updateApplications(applications) \u00b6 applications <Application[]> | Map New applications array or index obtained from jstp.createAppsIndex() . Replaces set of applications/applications versions available when connecting to the server. server.updateConnectionsApi() \u00b6 This function updates application version for each connection. It will update connection's application to the newest version in the range requested by the client. For example, if the client requested '1.1.x' range and was using version '1.1.1', it will be updated to the latest SemVer compatible version in this range (e.g. '1.1.2' , but not '1.2.x' ). If no suitable version is found, the client will use its previous app version. server.broadcast(interfaceName, eventName, ...args) \u00b6 interfaceName <string> eventName <string> ...args <any> Send event to all of the clients connected to the server.","title":"Server"},{"location":"api/server/#server","text":"","title":"Server"},{"location":"api/server/#class-jstpserver","text":"JSTP server base class with necessary methods. All of the transport servers extend this class.","title":"Class: jstp.Server"},{"location":"api/server/#event-connect","text":"<Connection> Emitted when a JSTP connection is established and new session is created.","title":"Event: 'connect'"},{"location":"api/server/#event-reconnect","text":"<Connection> Emitted when a JSTP connection is established that is reusing existing session .","title":"Event: 'reconnect'"},{"location":"api/server/#event-disconnect","text":"<Connection> Emitted when a JSTP connection is closed.","title":"Event: 'disconnect'"},{"location":"api/server/#servergetclients","text":"Returns: <Iterator> Get all clients as an Iterator of Connection instances.","title":"server.getClients()"},{"location":"api/server/#servergetclientsarray","text":"Returns: <Connection[]>","title":"server.getClientsArray()"},{"location":"api/server/#serverupdateapplicationsapplications","text":"applications <Application[]> | Map New applications array or index obtained from jstp.createAppsIndex() . Replaces set of applications/applications versions available when connecting to the server.","title":"server.updateApplications(applications)"},{"location":"api/server/#serverupdateconnectionsapi","text":"This function updates application version for each connection. It will update connection's application to the newest version in the range requested by the client. For example, if the client requested '1.1.x' range and was using version '1.1.1', it will be updated to the latest SemVer compatible version in this range (e.g. '1.1.2' , but not '1.2.x' ). If no suitable version is found, the client will use its previous app version.","title":"server.updateConnectionsApi()"},{"location":"api/server/#serverbroadcastinterfacename-eventname-args","text":"interfaceName <string> eventName <string> ...args <any> Send event to all of the clients connected to the server.","title":"server.broadcast(interfaceName, eventName, ...args)"},{"location":"api/session-storage-provider/","text":"SessionStorageProvider \u00b6 Interface: jstp.SessionStorageProvider \u00b6 This interface describes the storage provider for Session objects that may be used to persistently store sessions. Implementations may be synchronous or asynchronous. There is a default implementation provided in this package: jstp.SimpleSessionStorageProvider that stores all of the session data in memory and supports session expiration. ssp.isAsync() \u00b6 Returns: <boolean> The return value of this function is used to determine if the implementation of the provider is asynchronous. ssp.get(sessionId[, callback]) \u00b6 sessionId <string> callback <Function> Returns: <Session> | <undefined> Must return the Session object with the corresponding session ID or undefined if the session cannot be found. This method is called at most once for each connection on handshake, in case of session restoring when there is no connection associated with the session available in the server's cache (see clientExpirationTime option in jstp.net.createServer() ). If the session storage provider is asynchronous, it is expected to pass the Session object to the callback instead of returning it from the function. ssp.set(sessionId, session) \u00b6 sessionId <string> session <Session> Must save the Session object with the corresponding session ID. This method is called every time when connection associated with the session is being closed. ssp.setInactive(sessionId) \u00b6 sessionId <string> Optional method, can be omitted if this functionality is not required. If provided, must mark the session as inactive. Called whenever the connection associated with the session is being closed.","title":"SessionStorageProvider"},{"location":"api/session-storage-provider/#sessionstorageprovider","text":"","title":"SessionStorageProvider"},{"location":"api/session-storage-provider/#interface-jstpsessionstorageprovider","text":"This interface describes the storage provider for Session objects that may be used to persistently store sessions. Implementations may be synchronous or asynchronous. There is a default implementation provided in this package: jstp.SimpleSessionStorageProvider that stores all of the session data in memory and supports session expiration.","title":"Interface: jstp.SessionStorageProvider"},{"location":"api/session-storage-provider/#sspisasync","text":"Returns: <boolean> The return value of this function is used to determine if the implementation of the provider is asynchronous.","title":"ssp.isAsync()"},{"location":"api/session-storage-provider/#sspgetsessionid91-callback93","text":"sessionId <string> callback <Function> Returns: <Session> | <undefined> Must return the Session object with the corresponding session ID or undefined if the session cannot be found. This method is called at most once for each connection on handshake, in case of session restoring when there is no connection associated with the session available in the server's cache (see clientExpirationTime option in jstp.net.createServer() ). If the session storage provider is asynchronous, it is expected to pass the Session object to the callback instead of returning it from the function.","title":"ssp.get(sessionId[, callback])"},{"location":"api/session-storage-provider/#sspsetsessionid-session","text":"sessionId <string> session <Session> Must save the Session object with the corresponding session ID. This method is called every time when connection associated with the session is being closed.","title":"ssp.set(sessionId, session)"},{"location":"api/session-storage-provider/#sspsetinactivesessionid","text":"sessionId <string> Optional method, can be omitted if this functionality is not required. If provided, must mark the session as inactive. Called whenever the connection associated with the session is being closed.","title":"ssp.setInactive(sessionId)"},{"location":"api/session/","text":"Session \u00b6 Class: jstp.Session \u00b6 JSTP session class is used to buffer and resend the messages in case of unexpected connection closes. It extends Map class and thus can be used to store the current session state independently of connection. session.id \u00b6 <string> UUID v4 identifier of the session. session.connection \u00b6 <Connection> Link to the connection that is currently used in this session. session.username \u00b6 <string> The username that was used to log in for the first time in the session or null if 'anonymous' authentication strategy was used. session.toString() \u00b6 Returns: <string> Converts Session object to string. Must be used by implementers of session storage providers when exporting the Session objects. It is possible to lose some data due to this method using JSON for serialization. Session.fromString(sessionString) \u00b6 sessionString <string> Static method that restores Session object from string created by toString() method. Must be used by implementers of session storage providers when importing the Session objects.","title":"Session"},{"location":"api/session/#session","text":"","title":"Session"},{"location":"api/session/#class-jstpsession","text":"JSTP session class is used to buffer and resend the messages in case of unexpected connection closes. It extends Map class and thus can be used to store the current session state independently of connection.","title":"Class: jstp.Session"},{"location":"api/session/#sessionid","text":"<string> UUID v4 identifier of the session.","title":"session.id"},{"location":"api/session/#sessionconnection","text":"<Connection> Link to the connection that is currently used in this session.","title":"session.connection"},{"location":"api/session/#sessionusername","text":"<string> The username that was used to log in for the first time in the session or null if 'anonymous' authentication strategy was used.","title":"session.username"},{"location":"api/session/#sessiontostring","text":"Returns: <string> Converts Session object to string. Must be used by implementers of session storage providers when exporting the Session objects. It is possible to lose some data due to this method using JSON for serialization.","title":"session.toString()"},{"location":"api/session/#sessionfromstringsessionstring","text":"sessionString <string> Static method that restores Session object from string created by toString() method. Must be used by implementers of session storage providers when importing the Session objects.","title":"Session.fromString(sessionString)"},{"location":"api/simple-connect-policy/","text":"SimpleConnectPolicy \u00b6 Class: jstp.SimpleConnectPolicy \u00b6 Simple generic connection provider. Used for client-side connection. Sends handshake with login/password or session ID if provided, otherwise sends anonymous handshake. You are free to implement whatever suits your needs instead. simpleConnectPolicy.connect(app, connection[, session], callback) \u00b6 app <string> | <Object> application to connect to as 'name' or 'name@version' or { name, version } , where version must be a valid semver range. connection <Connection> session <Session> callback <Function> error <Error> | <null> connection Connection Should send handshake message with appropriate credentials. You can get client object provided upon connection creation with connection.client .","title":"SimpleConnectPolicy"},{"location":"api/simple-connect-policy/#simpleconnectpolicy","text":"","title":"SimpleConnectPolicy"},{"location":"api/simple-connect-policy/#class-jstpsimpleconnectpolicy","text":"Simple generic connection provider. Used for client-side connection. Sends handshake with login/password or session ID if provided, otherwise sends anonymous handshake. You are free to implement whatever suits your needs instead.","title":"Class: jstp.SimpleConnectPolicy"},{"location":"api/simple-connect-policy/#simpleconnectpolicyconnectapp-connection91-session-callback","text":"app <string> | <Object> application to connect to as 'name' or 'name@version' or { name, version } , where version must be a valid semver range. connection <Connection> session <Session> callback <Function> error <Error> | <null> connection Connection Should send handshake message with appropriate credentials. You can get client object provided upon connection creation with connection.client .","title":"simpleConnectPolicy.connect(app, connection[, session], callback)"},{"location":"api/simple-session-storage-provider/","text":"SimpleSessionStorageProvider \u00b6 Class: jstp.SimpleSessionStorageProvider \u00b6 This class implements jstp.SessionStorageProvider interface. Constructor: new SimpleSessionStorageProvider([inactiveSessionLifetime[, purgeInterval]]) \u00b6 inactiveSessionLifetime <number> Determines the minimal lifetime of the session which was marked as inactive in milliseconds. Defaults to 86400000 (24 hours). purgeInterval <number> Determines the interval at which session purging occurs in milliseconds. Defaults to 3600000 (1 hour).","title":"SimpleSessionStorageProvider"},{"location":"api/simple-session-storage-provider/#simplesessionstorageprovider","text":"","title":"SimpleSessionStorageProvider"},{"location":"api/simple-session-storage-provider/#class-jstpsimplesessionstorageprovider","text":"This class implements jstp.SessionStorageProvider interface.","title":"Class: jstp.SimpleSessionStorageProvider"},{"location":"api/simple-session-storage-provider/#constructor-new-simplesessionstorageprovider91inactivesessionlifetime91-purgeinterval9393","text":"inactiveSessionLifetime <number> Determines the minimal lifetime of the session which was marked as inactive in milliseconds. Defaults to 86400000 (24 hours). purgeInterval <number> Determines the interval at which session purging occurs in milliseconds. Defaults to 3600000 (1 hour).","title":"Constructor: new SimpleSessionStorageProvider([inactiveSessionLifetime[, purgeInterval]])"},{"location":"api/tls/","text":"tls \u00b6 Object: jstp.tls \u00b6 jstp.tls.connect(app, client, ...args, callback) \u00b6 app <string> | <Object> Application to connect to as 'name' or 'name@version' or { name, version } , where version must be a valid semver range. client <Client> | <null> Optional, when omitted, an object with the default values for application , connectPolicy and reconnector is used. ...args <any> Arguments passed directly to tls.connect() (except for callback ) callback <Function> error : <Error> connection : <Connection> jstp.tls.connectAndInspect(app, client, interfaces, ...args, callback) \u00b6 app <string> | <Object> Application to connect to as 'name' or 'name@version' or { name, version } , where version must be a valid semver range. client <Client> | <null> Optional, when omitted, an object with the default values for application , connectPolicy and reconnector is used. interfaces <string[]> Interface names to perform inspect on. ...args <any> Arguments passed directly to tls.connect() (except for callback ) callback <Function> error : <Error> connection : <Connection> proxies <Object> [interfaceName] <RemoteProxy> For more details see jstp.net.connectAndInspect() . jstp.tls.reconnect(connection, ...args, callback) \u00b6 connection : <Connection> ...args <any> Arguments passed directly to tls.connect() (except for callback ) callback <Function> error : <Error> connection : <Connection> For more details see jstp.net.reconnect() . jstp.tls.createServer(options[, listener]) \u00b6 options <Object> | <Application[]> applications <Application[]> | Map Applications array or index obtained from jstp.createAppsIndex() . authPolicy <AuthPolicy> | <Function> If the function is provided, it is expected to have the same signature as AuthPolicy.authenticate() . sessionStorageProvider <SessionStorageProvider> If provided, this is used to store sessions for applications that do not have its own storage provider. Defaults to using SimpleSessionStorageProvider with its default settings. heartbeatInterval <number> Omitting this option disables heartbeat. clientExpirationTime <number> Time it takes for client's connection and corresponding session cache, stored in memory after the connection is closed, to expire. Defaults to 3600000 (1 hour). listener <Function> Automatically set as a listener for the 'connect' event. For additional options see documentation for tls.createServer() . However, beware, some of the options may interfere with the correct functioning of the JSTP protocol. For more details see jstp.net.createServer()","title":"tls"},{"location":"api/tls/#tls","text":"","title":"tls"},{"location":"api/tls/#object-jstptls","text":"","title":"Object: jstp.tls"},{"location":"api/tls/#jstptlsconnectapp-client-args-callback","text":"app <string> | <Object> Application to connect to as 'name' or 'name@version' or { name, version } , where version must be a valid semver range. client <Client> | <null> Optional, when omitted, an object with the default values for application , connectPolicy and reconnector is used. ...args <any> Arguments passed directly to tls.connect() (except for callback ) callback <Function> error : <Error> connection : <Connection>","title":"jstp.tls.connect(app, client, ...args, callback)"},{"location":"api/tls/#jstptlsconnectandinspectapp-client-interfaces-args-callback","text":"app <string> | <Object> Application to connect to as 'name' or 'name@version' or { name, version } , where version must be a valid semver range. client <Client> | <null> Optional, when omitted, an object with the default values for application , connectPolicy and reconnector is used. interfaces <string[]> Interface names to perform inspect on. ...args <any> Arguments passed directly to tls.connect() (except for callback ) callback <Function> error : <Error> connection : <Connection> proxies <Object> [interfaceName] <RemoteProxy> For more details see jstp.net.connectAndInspect() .","title":"jstp.tls.connectAndInspect(app, client, interfaces, ...args, callback)"},{"location":"api/tls/#jstptlsreconnectconnection-args-callback","text":"connection : <Connection> ...args <any> Arguments passed directly to tls.connect() (except for callback ) callback <Function> error : <Error> connection : <Connection> For more details see jstp.net.reconnect() .","title":"jstp.tls.reconnect(connection, ...args, callback)"},{"location":"api/tls/#jstptlscreateserveroptions91-listener93","text":"options <Object> | <Application[]> applications <Application[]> | Map Applications array or index obtained from jstp.createAppsIndex() . authPolicy <AuthPolicy> | <Function> If the function is provided, it is expected to have the same signature as AuthPolicy.authenticate() . sessionStorageProvider <SessionStorageProvider> If provided, this is used to store sessions for applications that do not have its own storage provider. Defaults to using SimpleSessionStorageProvider with its default settings. heartbeatInterval <number> Omitting this option disables heartbeat. clientExpirationTime <number> Time it takes for client's connection and corresponding session cache, stored in memory after the connection is closed, to expire. Defaults to 3600000 (1 hour). listener <Function> Automatically set as a listener for the 'connect' event. For additional options see documentation for tls.createServer() . However, beware, some of the options may interfere with the correct functioning of the JSTP protocol. For more details see jstp.net.createServer()","title":"jstp.tls.createServer(options[, listener])"},{"location":"api/transport/","text":"Transport \u00b6 Interface: Transport \u00b6 Generic transport interface that is responsible for sending and receiving JSTP messages over the network protocol. Implementations must guarantee that the messages will be delivered in the same order in which they were sent. Event: 'message' \u00b6 message <Object> Parsed message. transport.send(data) \u00b6 data <string> | <Buffer> Serialized JSTP message. Send data over the connection. transport.end([data]) \u00b6 data <string> | <Buffer> Serialized JSTP message. End the connection optionally sending the last piece of data. transport.getRawTransport() \u00b6 Returns: <Object> Returns underlying transport object.","title":"Transport"},{"location":"api/transport/#transport","text":"","title":"Transport"},{"location":"api/transport/#interface-transport","text":"Generic transport interface that is responsible for sending and receiving JSTP messages over the network protocol. Implementations must guarantee that the messages will be delivered in the same order in which they were sent.","title":"Interface: Transport"},{"location":"api/transport/#event-message","text":"message <Object> Parsed message.","title":"Event: 'message'"},{"location":"api/transport/#transportsenddata","text":"data <string> | <Buffer> Serialized JSTP message. Send data over the connection.","title":"transport.send(data)"},{"location":"api/transport/#transportend91data93","text":"data <string> | <Buffer> Serialized JSTP message. End the connection optionally sending the last piece of data.","title":"transport.end([data])"},{"location":"api/transport/#transportgetrawtransport","text":"Returns: <Object> Returns underlying transport object.","title":"transport.getRawTransport()"},{"location":"api/ws-browser/","text":"ws for browser \u00b6 This module is loaded instead of jstp.ws when using the package in browser. Object: jstp.ws \u00b6 jstp.ws.connect(app, client, url, callback) \u00b6 app <string> | <Object> Application to connect to as 'name' or 'name@version' or { name, version } , where version must be a valid semver range. client <Client> | <null> Optional, when omitted, an object with the default values for application , connectPolicy and reconnector is used. url <string> callback <Function> error : <Error> connection : <Connection> jstp.ws.connectAndInspect(app, client, interfaces, url, callback) \u00b6 app <string> | <Object> Application to connect to as 'name' or 'name@version' or { name, version } , where version must be a valid semver range. client <Client> | <null> Optional, when omitted, an object with the default values for application , connectPolicy and reconnector is used. interfaces <string[]> Interface names to perform inspect on. url <string> callback <Function> error : <Error> connection : <Connection> proxies <Object> [interfaceName] <RemoteProxy> For more details see jstp.net.connectAndInspect() . jstp.ws.reconnect(connection, url, callback) \u00b6 connection : <Connection> url <string> callback <Function> error : <Error> connection : <Connection> For more details see jstp.net.reconnect() .","title":"ws-browser"},{"location":"api/ws-browser/#ws-for-browser","text":"This module is loaded instead of jstp.ws when using the package in browser.","title":"ws for browser"},{"location":"api/ws-browser/#object-jstpws","text":"","title":"Object: jstp.ws"},{"location":"api/ws-browser/#jstpwsconnectapp-client-url-callback","text":"app <string> | <Object> Application to connect to as 'name' or 'name@version' or { name, version } , where version must be a valid semver range. client <Client> | <null> Optional, when omitted, an object with the default values for application , connectPolicy and reconnector is used. url <string> callback <Function> error : <Error> connection : <Connection>","title":"jstp.ws.connect(app, client, url, callback)"},{"location":"api/ws-browser/#jstpwsconnectandinspectapp-client-interfaces-url-callback","text":"app <string> | <Object> Application to connect to as 'name' or 'name@version' or { name, version } , where version must be a valid semver range. client <Client> | <null> Optional, when omitted, an object with the default values for application , connectPolicy and reconnector is used. interfaces <string[]> Interface names to perform inspect on. url <string> callback <Function> error : <Error> connection : <Connection> proxies <Object> [interfaceName] <RemoteProxy> For more details see jstp.net.connectAndInspect() .","title":"jstp.ws.connectAndInspect(app, client, interfaces, url, callback)"},{"location":"api/ws-browser/#jstpwsreconnectconnection-url-callback","text":"connection : <Connection> url <string> callback <Function> error : <Error> connection : <Connection> For more details see jstp.net.reconnect() .","title":"jstp.ws.reconnect(connection, url, callback)"},{"location":"api/ws/","text":"ws \u00b6 Object: jstp.ws \u00b6 jstp.ws.connect(app, client, webSocketConfig, requestUrl, callback) \u00b6 app <string> | <Object> Application to connect to as 'name' or 'name@version' or { name, version } , where version must be a valid semver range. client <Client> | <null> Optional, when omitted, an object with the default values for application , connectPolicy and reconnector is used. webSocketConfig <WebSocketClientConfig> requestUrl <string> | <URL> callback <Function> error : <Error> connection : <Connection> jstp.ws.connectAndInspect(app, client, interfaces, webSocketConfig, requestUrl, callback) \u00b6 app <string> | <Object> Application to connect to as 'name' or 'name@version' or { name, version } , where version must be a valid semver range. client <Client> | <null> Optional, when omitted, an object with the default values for application , connectPolicy and reconnector is used. interfaces <string[]> Interface names to perform inspect on. webSocketConfig <WebSocketClientConfig> requestUrl <string> | <URL> callback <Function> error : <Error> connection : <Connection> proxies <Object> [interfaceName] <RemoteProxy> For more details see jstp.net.connectAndInspect() . jstp.ws.reconnect(connection, webSocketConfig, requestUrl, callback) \u00b6 connection : <Connection> webSocketConfig <WebSocketClientConfig> requestUrl <string> | <URL> callback <Function> error : <Error> connection : <Connection> For more details see jstp.net.reconnect() . jstp.ws.createServer(options[, listener]) \u00b6 options <Object> | <Application[]> applications <Application[]> | Map Applications array or index obtained from jstp.createAppsIndex() . authPolicy <AuthPolicy> | <Function> If the function is provided, it is expected to have the same signature as AuthPolicy.authenticate() . sessionStorageProvider <SessionStorageProvider> If provided, this is used to store sessions for applications that do not have its own storage provider. Defaults to using SimpleSessionStorageProvider with its default settings. heartbeatInterval <number> Omitting this option disables heartbeat. clientExpirationTime <number> Time it takes for client's connection and corresponding session cache, stored in memory after the connection is closed, to expire. Defaults to 3600000 (1 hour). listener <Function> Automatically set as a listener for the 'connect' event. For additional options see documentation for WebSocketServer . Some of the options are not configurable, though, in particular httpServer , autoAcceptConnections , maxReceivedFrameSize , and maxReceivedMessageSize . However, beware, some of the other options may interfere with the correct functioning of the JSTP protocol. For more details see jstp.net.createServer()","title":"ws"},{"location":"api/ws/#ws","text":"","title":"ws"},{"location":"api/ws/#object-jstpws","text":"","title":"Object: jstp.ws"},{"location":"api/ws/#jstpwsconnectapp-client-websocketconfig-requesturl-callback","text":"app <string> | <Object> Application to connect to as 'name' or 'name@version' or { name, version } , where version must be a valid semver range. client <Client> | <null> Optional, when omitted, an object with the default values for application , connectPolicy and reconnector is used. webSocketConfig <WebSocketClientConfig> requestUrl <string> | <URL> callback <Function> error : <Error> connection : <Connection>","title":"jstp.ws.connect(app, client, webSocketConfig, requestUrl, callback)"},{"location":"api/ws/#jstpwsconnectandinspectapp-client-interfaces-websocketconfig-requesturl-callback","text":"app <string> | <Object> Application to connect to as 'name' or 'name@version' or { name, version } , where version must be a valid semver range. client <Client> | <null> Optional, when omitted, an object with the default values for application , connectPolicy and reconnector is used. interfaces <string[]> Interface names to perform inspect on. webSocketConfig <WebSocketClientConfig> requestUrl <string> | <URL> callback <Function> error : <Error> connection : <Connection> proxies <Object> [interfaceName] <RemoteProxy> For more details see jstp.net.connectAndInspect() .","title":"jstp.ws.connectAndInspect(app, client, interfaces, webSocketConfig, requestUrl, callback)"},{"location":"api/ws/#jstpwsreconnectconnection-websocketconfig-requesturl-callback","text":"connection : <Connection> webSocketConfig <WebSocketClientConfig> requestUrl <string> | <URL> callback <Function> error : <Error> connection : <Connection> For more details see jstp.net.reconnect() .","title":"jstp.ws.reconnect(connection, webSocketConfig, requestUrl, callback)"},{"location":"api/ws/#jstpwscreateserveroptions91-listener93","text":"options <Object> | <Application[]> applications <Application[]> | Map Applications array or index obtained from jstp.createAppsIndex() . authPolicy <AuthPolicy> | <Function> If the function is provided, it is expected to have the same signature as AuthPolicy.authenticate() . sessionStorageProvider <SessionStorageProvider> If provided, this is used to store sessions for applications that do not have its own storage provider. Defaults to using SimpleSessionStorageProvider with its default settings. heartbeatInterval <number> Omitting this option disables heartbeat. clientExpirationTime <number> Time it takes for client's connection and corresponding session cache, stored in memory after the connection is closed, to expire. Defaults to 3600000 (1 hour). listener <Function> Automatically set as a listener for the 'connect' event. For additional options see documentation for WebSocketServer . Some of the options are not configurable, though, in particular httpServer , autoAcceptConnections , maxReceivedFrameSize , and maxReceivedMessageSize . However, beware, some of the other options may interfere with the correct functioning of the JSTP protocol. For more details see jstp.net.createServer()","title":"jstp.ws.createServer(options[, listener])"},{"location":"api/wss/","text":"wss \u00b6 Object: jstp.wss \u00b6 jstp.wss.createServer(options[, listener]) \u00b6 options <Object> | <Application[]> applications <Application[]> | Map Applications array or index obtained from jstp.createAppsIndex() . authPolicy <AuthPolicy> | <Function> If the function is provided, it is expected to have the same signature as AuthPolicy.authenticate() . sessionStorageProvider <SessionStorageProvider> If provided, this is used to store sessions for applications that do not have its own storage provider. Defaults to using SimpleSessionStorageProvider with its default settings. heartbeatInterval <number> Omitting this option disables heartbeat. clientExpirationTime <number> Time it takes for client's connection and corresponding session cache, stored in memory after the connection is closed, to expire. Defaults to 3600000 (1 hour). listener <Function> Automatically set as a listener for the 'connect' event. For more details see jstp.ws.createServer() .","title":"wss"},{"location":"api/wss/#wss","text":"","title":"wss"},{"location":"api/wss/#object-jstpwss","text":"","title":"Object: jstp.wss"},{"location":"api/wss/#jstpwsscreateserveroptions91-listener93","text":"options <Object> | <Application[]> applications <Application[]> | Map Applications array or index obtained from jstp.createAppsIndex() . authPolicy <AuthPolicy> | <Function> If the function is provided, it is expected to have the same signature as AuthPolicy.authenticate() . sessionStorageProvider <SessionStorageProvider> If provided, this is used to store sessions for applications that do not have its own storage provider. Defaults to using SimpleSessionStorageProvider with its default settings. heartbeatInterval <number> Omitting this option disables heartbeat. clientExpirationTime <number> Time it takes for client's connection and corresponding session cache, stored in memory after the connection is closed, to expire. Defaults to 3600000 (1 hour). listener <Function> Automatically set as a listener for the 'connect' event. For more details see jstp.ws.createServer() .","title":"jstp.wss.createServer(options[, listener])"},{"location":"cli/","text":"CLI \u00b6 JSTP comes bundled with an interactive REPL that allows you to interact with JSTP servers for testing or debugging purposes, much like you use curl or Postman to interact with HTTP servers. To install it globally, run: npm install -g @metarhia/jstp You can then use it by running jstp-cli command with the needed options. To get a basic help message, you can run: jstp-cli --help To get more detailed information on how to use the tool and the list of all available options, use: man jstp-cli","title":"JSTP CLI"},{"location":"cli/#cli","text":"JSTP comes bundled with an interactive REPL that allows you to interact with JSTP servers for testing or debugging purposes, much like you use curl or Postman to interact with HTTP servers. To install it globally, run: npm install -g @metarhia/jstp You can then use it by running jstp-cli command with the needed options. To get a basic help message, you can run: jstp-cli --help To get more detailed information on how to use the tool and the list of all available options, use: man jstp-cli","title":"CLI"},{"location":"meetings/2017-02-21-sessions/","text":"Sessions WG meeting \u00b6 Date: 2017-02-21 Invited \u00b6 Alexey Orlenko <eaglexrlnk@gmail.com> ( @aqrln ) from server team Mykola Bilochub <nbelochub@gmail.com> ( @belochub ) from server team Denys Otrishko <shishugi@gmail.com> ( @lundibundi ) from Android team Andrew Vysotskyi <firemaaaan@gmail.com> ( @Gagnant ) from iOS team Present \u00b6 Alexey Orlenko <eaglexrlnk@gmail.com> ( @aqrln ) from server team Mykola Bilochub <nbelochub@gmail.com> ( @belochub ) from server team Denys Otrishko <shishugi@gmail.com> ( @lundibundi ) from Android team Agenda \u00b6 General way of reconnection to existing sessions; Session restoration mechanisms architecture; The problems with reconnection mobile developers encountered in our last project and proper ways to solve them; Handshake packet formats (for request and response) that will be used to implement reconnection to existing sessions. Conclusions \u00b6 To make packet numbers unique for every session, not connection like it was before; To send total count of packets sent and received by each side during the session in handshake packet, like this: javascript { handshake: [0, 'appName'], session: ['sessionId', sent_count, received_count] } and answer javascript { handshake: [0], ok: [sent_count, received_count] } Post-discussion additions \u00b6 Even though packet IDs are incremented throughout the session, not the connection, handshake packets are always 0 since we don't know which packet IDs to use until a handshake has been performed. After that, the order continues as it should have been if there hadn't been reconnection, with an extra handshake being transparent. The standard ERR_AUTH_FAILED error will be used for any handshake authentication strategy, regardless of it being login , session or anything we may probably add later. What it means for session restoration handshakes is that if session ID is invalid, the server responds with javascript { handshake: [0], error: [11] } UPD: Packet term was renamed to message hence every place packet is mentioned message should be assumed instead.","title":"Sessions WG meeting"},{"location":"meetings/2017-02-21-sessions/#sessions-wg-meeting","text":"Date: 2017-02-21","title":"Sessions WG meeting"},{"location":"meetings/2017-02-21-sessions/#invited","text":"Alexey Orlenko <eaglexrlnk@gmail.com> ( @aqrln ) from server team Mykola Bilochub <nbelochub@gmail.com> ( @belochub ) from server team Denys Otrishko <shishugi@gmail.com> ( @lundibundi ) from Android team Andrew Vysotskyi <firemaaaan@gmail.com> ( @Gagnant ) from iOS team","title":"Invited"},{"location":"meetings/2017-02-21-sessions/#present","text":"Alexey Orlenko <eaglexrlnk@gmail.com> ( @aqrln ) from server team Mykola Bilochub <nbelochub@gmail.com> ( @belochub ) from server team Denys Otrishko <shishugi@gmail.com> ( @lundibundi ) from Android team","title":"Present"},{"location":"meetings/2017-02-21-sessions/#agenda","text":"General way of reconnection to existing sessions; Session restoration mechanisms architecture; The problems with reconnection mobile developers encountered in our last project and proper ways to solve them; Handshake packet formats (for request and response) that will be used to implement reconnection to existing sessions.","title":"Agenda"},{"location":"meetings/2017-02-21-sessions/#conclusions","text":"To make packet numbers unique for every session, not connection like it was before; To send total count of packets sent and received by each side during the session in handshake packet, like this: javascript { handshake: [0, 'appName'], session: ['sessionId', sent_count, received_count] } and answer javascript { handshake: [0], ok: [sent_count, received_count] }","title":"Conclusions"},{"location":"meetings/2017-02-21-sessions/#post-discussion-additions","text":"Even though packet IDs are incremented throughout the session, not the connection, handshake packets are always 0 since we don't know which packet IDs to use until a handshake has been performed. After that, the order continues as it should have been if there hadn't been reconnection, with an extra handshake being transparent. The standard ERR_AUTH_FAILED error will be used for any handshake authentication strategy, regardless of it being login , session or anything we may probably add later. What it means for session restoration handshakes is that if session ID is invalid, the server responds with javascript { handshake: [0], error: [11] } UPD: Packet term was renamed to message hence every place packet is mentioned message should be assumed instead.","title":"Post-discussion additions"},{"location":"meetings/2017-04-11-core/","text":"2017-04-11 JSTP Core Maintainers Meeting \u00b6 Invited: Alexey Orlenko <eaglexrlnk@gmail.com> ( @aqrln ) Denys Otrishko <shishugi@gmail.com> ( @lundibundi ) Dmytro Nechai <nechaido@gmail.com> ( @nechaido ) Mykola Bilochub <nbelochub@gmail.com> ( @belochub ) Timur Shemsedinov <timur.shemsedinov@gmail.com> ( @tshemsedinov ) Present: Alexey Orlenko <eaglexrlnk@gmail.com> ( @aqrln ) Denys Otrishko <shishugi@gmail.com> ( @lundibundi ) Dmytro Nechai <nechaido@gmail.com> ( @nechaido ) Mykola Bilochub <nbelochub@gmail.com> ( @belochub ) Timur Shemsedinov <timur.shemsedinov@gmail.com> ( @tshemsedinov ) Agenda \u00b6 Contribution guidelines. Relationship with https://github.com/jstp . Compliance with JSON5 specs. The future of our custom data formats. The front page of the project. Decisions \u00b6 1. Contribution guidelines \u00b6 The number of active contributors has doubled over the last time, so the existing policy that allowed landing PRs as soon as they are approved does not work anymore. We have already encountered a situation when a PR has landed prematurely without a proper review from a collaborator other than one who had reviewed it and, consequently, without addressing their feedback. Because of that we need a minimal waiting time, which we have agreed upon to be 24 hours, skipping weekends and holidays. That, and all the conventions that we have had, must be documented. 2. Relationship with https://github.com/jstp \u00b6 Using the name \"JSTP\" when another similar project with the same name has already existed (even though it has been inactive for a long time) is inappropriate, may lead to confusion and is a potential infringement. We must get in touch with the people behind it and either get approval to use the name or rename our project. 3. Compliance with JSON5 specs. The future of our custom data formats \u00b6 What has been called \"Record Serialization\" should be plain JSON5. Given the fact that we have implemented some minor features not present in JSON5 specs (like ES2015 syntax for octal and binary literals), it is okay if we keep them, but the parser must be able to parse any valid JSON5 and the serializer must emit strict JSON5. In the future we might also consider decoupling the serdes facilities built into the JSTP into a separate npm package (like \"fast-json5\" or \"metarhia-json5\"). What has been called \"Object Serialization\" should be removed from the codebase. There's no sensible use case for it and there's no way to implement it in secure and performant fashion. 4. The front page of the project \u00b6 The README.md file should be updated to reflect the current vision of the project. It is misleading in some points and makes people who try to get acquainted with the project confused. Besides that, a new section with the list of the project's maintainers should be added.","title":"2017-04-11 JSTP Core Maintainers Meeting"},{"location":"meetings/2017-04-11-core/#2017-04-11-jstp-core-maintainers-meeting","text":"Invited: Alexey Orlenko <eaglexrlnk@gmail.com> ( @aqrln ) Denys Otrishko <shishugi@gmail.com> ( @lundibundi ) Dmytro Nechai <nechaido@gmail.com> ( @nechaido ) Mykola Bilochub <nbelochub@gmail.com> ( @belochub ) Timur Shemsedinov <timur.shemsedinov@gmail.com> ( @tshemsedinov ) Present: Alexey Orlenko <eaglexrlnk@gmail.com> ( @aqrln ) Denys Otrishko <shishugi@gmail.com> ( @lundibundi ) Dmytro Nechai <nechaido@gmail.com> ( @nechaido ) Mykola Bilochub <nbelochub@gmail.com> ( @belochub ) Timur Shemsedinov <timur.shemsedinov@gmail.com> ( @tshemsedinov )","title":"2017-04-11 JSTP Core Maintainers Meeting"},{"location":"meetings/2017-04-11-core/#agenda","text":"Contribution guidelines. Relationship with https://github.com/jstp . Compliance with JSON5 specs. The future of our custom data formats. The front page of the project.","title":"Agenda"},{"location":"meetings/2017-04-11-core/#decisions","text":"","title":"Decisions"},{"location":"meetings/2017-04-11-core/#1-contribution-guidelines","text":"The number of active contributors has doubled over the last time, so the existing policy that allowed landing PRs as soon as they are approved does not work anymore. We have already encountered a situation when a PR has landed prematurely without a proper review from a collaborator other than one who had reviewed it and, consequently, without addressing their feedback. Because of that we need a minimal waiting time, which we have agreed upon to be 24 hours, skipping weekends and holidays. That, and all the conventions that we have had, must be documented.","title":"1. Contribution guidelines"},{"location":"meetings/2017-04-11-core/#2-relationship-with-httpsgithubcomjstp","text":"Using the name \"JSTP\" when another similar project with the same name has already existed (even though it has been inactive for a long time) is inappropriate, may lead to confusion and is a potential infringement. We must get in touch with the people behind it and either get approval to use the name or rename our project.","title":"2. Relationship with https://github.com/jstp"},{"location":"meetings/2017-04-11-core/#3-compliance-with-json5-specs-the-future-of-our-custom-data-formats","text":"What has been called \"Record Serialization\" should be plain JSON5. Given the fact that we have implemented some minor features not present in JSON5 specs (like ES2015 syntax for octal and binary literals), it is okay if we keep them, but the parser must be able to parse any valid JSON5 and the serializer must emit strict JSON5. In the future we might also consider decoupling the serdes facilities built into the JSTP into a separate npm package (like \"fast-json5\" or \"metarhia-json5\"). What has been called \"Object Serialization\" should be removed from the codebase. There's no sensible use case for it and there's no way to implement it in secure and performant fashion.","title":"3. Compliance with JSON5 specs. The future of our custom data formats"},{"location":"meetings/2017-04-11-core/#4-the-front-page-of-the-project","text":"The README.md file should be updated to reflect the current vision of the project. It is misleading in some points and makes people who try to get acquainted with the project confused. Besides that, a new section with the list of the project's maintainers should be added.","title":"4. The front page of the project"},{"location":"tutorial/","text":"Tutorial \u00b6 After reading this section and completing exercises you'll get a grasp of JSTP and will be able to use it in your projects.","title":"Tutorial"},{"location":"tutorial/#tutorial","text":"After reading this section and completing exercises you'll get a grasp of JSTP and will be able to use it in your projects.","title":"Tutorial"}]}